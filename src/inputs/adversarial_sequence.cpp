#include <cmath>
#include <cstdio>
#include <fstream>
#include <ostream>
#include <string>
#include <filesystem>
#include <sys/stat.h>

#include "inputs/adversarial_sequence.hpp"
#include "inputs/all_commands_manager.hpp"
#include "kernel/constants.hpp"

namespace inputs
{

void AdversarialSequence::generateRawResultsPath()
{
    if (this->getIfItIsAStaticSequence() == false)
    {
        this->rawResultsPath = OUTPUT_DIR_FUZZING_RESULTS "/" + std::to_string(this->getDepth() - 1) + "/" + std::to_string(this->getID());
    }
    else
    {
        this->rawResultsPath = OUTPUT_DIR_STATIC_RESULTS "/" + std::to_string(this->getDepth() - 1) + "/" + std::to_string(this->getID());
    }
}

void AdversarialSequence::determineIfItIsAStaticSequence()
{
    this->isAStaticSequence = AllCommandsManager::commandIsStatic(this->allCommandsManager.getCommand(this->lastCommandId));
}

void AdversarialSequence::generateWildcardFiles() const
{
    std::string wildcardContent;
    std::ifstream fileIfstream;
    std::string wildcardContentBuffer;
    std::string lastCommand;
    std::ofstream fileOfStream;
    std::string filePath;
    mode_t directoryMode = S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH; // 0o755 drwxr-xr-x
    bool previousSequenceIsStatic = this->previousAdversarialSequence->getIfItIsAStaticSequence();
    std::filesystem::directory_entry previousSequencePath;

    if (this->previousAdversarialSequence != nullptr)
    {
        mkdir(this->getWildcardPath().c_str(), directoryMode);

        // We iterate over results of the previous adversarial sequence
        for (const std::filesystem::directory_entry& file : std::filesystem::directory_iterator(this->previousAdversarialSequence->getFinalResultsPath()))
        {
            wildcardContent = "";

            if ((previousSequenceIsStatic == true) && (previousAdversarialSequence->getDepth() > 1)) // Depth > 1 because for original static sequences generated by cslprocess, the file is directly accessible.
            {
                previousSequencePath = std::filesystem::directory_entry(file.path().string() + "/command_sequence");
            }
            else
            {
                previousSequencePath = file;
            }

            fileIfstream = std::ifstream(previousSequencePath.path());

            while (std::getline(fileIfstream, wildcardContentBuffer))
            {
                wildcardContent += wildcardContentBuffer + "\n";
            }

            fileIfstream.close();

            // We add the last command of the adversarial sequence to the result
            lastCommand = this->allCommandsManager.getCommand(this->lastCommandId);
            wildcardContent += lastCommand;

            // We generate the new file that contains the new wildcard content

            filePath = this->getWildcardPath() + "/" + previousSequencePath.path().filename().string();
            fileOfStream = std::ofstream(filePath);

            fileOfStream << wildcardContent << std::endl;

            fileOfStream.close();
        }
    }
}

void AdversarialSequence::generateFinalResultsPath()
{
    if (this->getIfItIsAStaticSequence() == true)
    {
        this->finalResultsPath = this->rawResultsPath;
    }
    else
    {
        this->finalResultsPath = OUTPUT_DIR_APPLY_WILDCARD "/" + std::to_string(this->getDepth() - 1) + "/" + std::to_string(this->getID());
    }
}

AdversarialSequence::AdversarialSequence(const AllCommandsManager& _allCommandsManager, std::string _firstCommand) :
    previousAdversarialSequence(nullptr),
    allCommandsManager(_allCommandsManager)
{
    this->lastCommandId = this->allCommandsManager.getID(_firstCommand);

    this->determineIfItIsAStaticSequence();
    this->generateRawResultsPath();
    this->generateFinalResultsPath();
}

AdversarialSequence::AdversarialSequence(const AdversarialSequence* _previousAdversarialSequence, std::string _nextCommand) :
    previousAdversarialSequence(_previousAdversarialSequence),
    allCommandsManager(_previousAdversarialSequence->allCommandsManager)
{
    this->lastCommandId = this->allCommandsManager.getID(_nextCommand);

    this->generateWildcardFiles();
    this->determineIfItIsAStaticSequence();
    this->generateRawResultsPath();
    this->generateFinalResultsPath();
}

int AdversarialSequence::getDepth() const
{
    int result;

    if (this->previousAdversarialSequence != nullptr)
    {
        result = 1 + this->previousAdversarialSequence->getDepth();
    }
    else
    {
        result = 1;
    }

    return result;
}

int AdversarialSequence::getID() const
{
    int result;

    if (this->previousAdversarialSequence != nullptr)
    {
        result = std::pow(this->allCommandsManager.getNumberOfCommands(), this->getDepth() - 1) * this->previousAdversarialSequence->getID() + this->lastCommandId;
    }
    else
    {
        result = this->lastCommandId;
    }

    return result;
}

std::string AdversarialSequence::getRawResultsPath() const
{
    return this->rawResultsPath;
}

std::string AdversarialSequence::getWildcardPath() const
{
    std::string result;

    if (this->getDepth() == 1)
    {
        result = CSLPROCESS_V2_ALL_COMMANDS_DIR "/" + std::to_string(this->lastCommandId) + ".cmd";
    }
    else
    {
        result = OUTPUT_DIR_NEXT_COMMAND_SEQUENCES "/" + std::to_string(this->getDepth() - 1) + "/" + std::to_string(this->getID());
    }

    return result;
}

bool AdversarialSequence::getIfItIsAStaticSequence() const
{
    return this->isAStaticSequence;
}

std::string AdversarialSequence::getFinalResultsPath() const
{
    return this->finalResultsPath;
}

} // namespace inputs