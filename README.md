# Tulip: Command-based Backdoor Detector (CBD): The main tool

- [Tulip: Command-based Backdoor Detector (CBD): The main tool](#tulip-command-based-backdoor-detector-cbd-the-main-tool)
  - [1) Introduction](#1-introduction)
    - [1.1) Dependencies](#11-dependencies)
    - [1.2) Build](#12-build)
  - [2) Preparation](#2-preparation)
  - [3) Testing the target](#3-testing-the-target)
    - [3.1) Building a testing strategy](#31-building-a-testing-strategy)
    - [3.2) Outputs and artifacts](#32-outputs-and-artifacts)
    - [3.3) Found backdoors](#33-found-backdoors)
  - [4) Ablation studies](#4-ablation-studies)

## 1) Introduction

CBD *(For Command-based Backdoor Detector)* is the main Tulip tool letting to find backdoors (Eg: Authentications bypasses) on programs that:
- Rely on command exchanges
- Have an authentication mechanism based on commands

Tulip is strongly built around an automaton representation of the target
- Example of POP3 automaton used to test the QMail POP3 implementation:
  - ![POP3 automaton](doc/.assets/POP3_automaton.png)

The main idea is to find combinations of commands and args that violate authentication rules. For example, let's take this normal command sequence that permit to the user `milhouse` to read its new mails:
```
USER milhouse
PASS lisa
LIST
```

In depth, the legitimate user `milhouse` has to use the command `USER milhouse`, then `PASS lisa` to be able to read his mails through the command `LIST`.

An attacker could introduce a malicious user `homer` that permits to have access to `milhouse`'s mails:
```
USER homer
PASS marge
LIST
```

The goal of Tulip is to find that the following sequence is illegal, and is a part of a backdoor:
```
USER homer
PASS marge
```

In depth, an analysis is done in 2 main phases:
- The first one is based on fuzzing ([AFL++](https://github.com/AFLplusplus/AFLplusplus)), in order to generate lot of inputs
- The second one is based on oracle testing, to determine problematic outputs that leads to backdoors

### 1.1) Dependencies

To build Tulip, you need to have a functional C and C++ compiler (GCC and clang are good candidates).

### 1.2) Build

To build Tulip, you need to do:
```bash
$ make
```

## 2) Preparation

See [Preparation section](doc/Preparation.md)

## 3) Testing the target

Once previous steps are done, everything is fine to test the target and finding backdoors in it!

### 3.1) Building a testing strategy

Here is the main usage manual from the built binary:
```
Usage : ./cbd [OPTIONS] <csl_file> <binary_to_fuzz_RADICAL> <time_to_fuzz_a_wildcard_in_s> <max_command_sequences_depth> <number_of_concurrent_threads> [binary_to_fuzz_args...]
Options :
-f : Full fuzzing mode => Fuzz with 1 main fuzzer, 1 cmplog and 3 compcov AFL++ instances
-s : Partial fuzzing mode => Fuzz with 1 main fuzzer, 1 cmplog and 1 compcov AFL++ instances
-c : Cmplog minimal fuzzing mode => Fuzz with only 1 main cmplog AFL++ instance
-C : Compcov minimal fuzzing mode => Fuzz with only 1 main compcov AFL++ instance
-S : Standard minimal fuzzing mode => Fuzz with only 1 main standard AFL++ instance
-T : Custom fuzzing time per fuzzing session -> Now, the parameter "time_to_fuzz_a_wildcard_in_s" has the form "time_to_fuzz_a_wildcard_in_s_for_fuzzing_session_1,time_to_fuzz_a_wildcard_in_s_for_fuzzing_session_2,...", so there is the same number of values as "max_command_sequences_depth"
```

### 3.2) Outputs and artifacts

Just after launching Tulip, a directory `output` is created. Here is an explanation of its main content :
- `afl/`: Outputs of the fuzzers. A path like `afl/0/coreid=5` means fuzzing stage 0, and fuzzing core 5. Under this directory, there are :
  - `afl_stdout` and `afl_stderr`: `stdout`/`stderr` corresponding to the associated AFL++ run
  - `main`/`sec_cmplg`/...: Output directory corresponding to the associated AFL++ run
    - Under these directories, there are the files and directories commonly generated by a vanilla AFL++ run : `queue/`/`fuzzer_stats`/etc.
- `apply_wildcard`: For each fuzzing stage, pooling of the generated seeds, and application of the associated wildcard (Wildcard: `PASS *-{lisa}`, Input: `toto` $\Longrightarrow$ `PASS toto`)
- `csl`: Stuff generated by `cslprocess` according to the provided CSL specification
- `potential_backdoors`: Potential backdoors found by the oracle
- `seeds`: Initial seeds for the fuzzing cores
- `static`: Static sequences that does not need further fuzzing
- `syscalls`: Got system calls when exercising the target with the generated and static commands sequences
- `wildcards`: Wildcards used for each stage

### 3.3) Found backdoors

Potentially found backdoors are available under `output/potential_backdoors`. If a backdoor is detected because it introduces unauthorized system calls, a file `__report__.txt` is created, summarizing forbidden system calls.

## 4) Ablation studies

To build and install ablated versions of Tulip, you have to patch the repo :
```bash
$ patch -p1 -R < partial_versions_patches/<ablation>.patch
```

Then, you can build it by following the section [1.2](#12-build).
